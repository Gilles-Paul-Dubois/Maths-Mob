<html>
<head>
<title>repeuc.jl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">

<pre><span class="s0">include(</span><span class="s1">&quot;euclidiens.jl&quot;</span><span class="s0">)</span>
<span class="s2">using </span><span class="s0">LinearAlgebra </span><span class="s3">#pour det</span>

<span class="s3">#repère euclidien - Euclidean frame</span>
<span class="s2">struct </span><span class="s0">OVS{T}</span>
    <span class="s0">O::Point{T}</span>
    <span class="s0">VS::VectorsSystem{T}</span>
<span class="s2">end</span>

<span class="s0">delcol(M,j)=hcat([[M[i,h] </span><span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:size(M,</span><span class="s4">1</span><span class="s0">)] </span><span class="s2">for </span><span class="s0">h </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:size(M,</span><span class="s4">2</span><span class="s0">) </span><span class="s2">if </span><span class="s0">h !=j]...) </span><span class="s3">#suppresion colonne j - delete column j</span>
<span class="s3"># l'hyperplan est donné par un repère affine, une structure de type OVS</span>
<span class="s3"># hyperplane is given with an affine frame ,an OVS structure</span>
<span class="s2">function </span><span class="s0">equanorm(HP::OVS{T}) </span><span class="s2">where </span><span class="s0">T </span><span class="s3">#calcul de l'équation normale - computation of normal equation'</span>
    <span class="s0">O=HP.O</span>
    <span class="s0">VS=HP.VS</span>
    <span class="s0">M=matrice(VS)</span>
    <span class="s0">s1,s2=size(M,</span><span class="s4">1</span><span class="s0">),size(M,</span><span class="s4">2</span><span class="s0">)</span>
    <span class="s0">F=[det(delcol(M,j)) </span><span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:s2]</span>
    <span class="s0">E=[ j%</span><span class="s4">2</span><span class="s0">!=</span><span class="s4">0 </span><span class="s0">? F[j] : -F[j]  </span><span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:s2]</span>
    <span class="s0">n=norme(E)</span>
    <span class="s0">CO=O.C</span>
    <span class="s0">G=[E[j]*CO[j] </span><span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:s2]</span>
    <span class="s0">k=reduce(+,G)</span>
    <span class="s0">push!(E,-k)</span>
    <span class="s2">return </span><span class="s0">inv(n)*E </span><span class="s3">#retourne sous forme de liste les coeffs de x,y,z, etc... le dernier est le terme constant - returns as a list the coeffs of x,y,z the last one is a constant</span>
<span class="s2">end</span>
<span class="s3">#distance du point P à l'hyperplan HP - distance of point P to hyperplane HP</span>
<span class="s2">function </span><span class="s0">distance(HP::OVS{T},P::Point{T}) </span><span class="s2">where </span><span class="s0">T</span>
    <span class="s0">E=equanorm(HP)</span>
    <span class="s0">CO=P.C</span>
    <span class="s0">F=E[</span><span class="s4">1</span><span class="s0">:end-</span><span class="s4">1</span><span class="s0">]</span>
    <span class="s0">G=[F[j]*CO[j] </span><span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s4">1</span><span class="s0">:length(CO)]</span>
    <span class="s0">d=reduce(+,G)</span>
    <span class="s0">d+=E[</span><span class="s2">end</span><span class="s0">]</span>
    <span class="s2">return </span><span class="s0">abs(d)</span>
<span class="s2">end</span>

<span class="s2">function </span><span class="s0">testetout()</span>
    <span class="s0">P=QP([</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s0">,</span><span class="s4">3</span><span class="s0">])</span>
    <span class="s0">dirs=VSQ([[</span><span class="s4">1</span><span class="s0">//</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">//</span><span class="s4">1</span><span class="s0">,</span><span class="s4">3</span><span class="s0">//</span><span class="s4">1</span><span class="s0">],[</span><span class="s4">0</span><span class="s0">//</span><span class="s4">1</span><span class="s0">,</span><span class="s4">2</span><span class="s0">//</span><span class="s4">1</span><span class="s0">,</span><span class="s4">4</span><span class="s0">//</span><span class="s4">1</span><span class="s0">]])</span>
    <span class="s0">HP=OVS{Rational{Int64}}(P,dirs)</span>
    <span class="s0">println(equanorm(HP))</span>
    <span class="s0">Q=QP([</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s0">,</span><span class="s4">4</span><span class="s0">])</span>
    <span class="s0">println(distance(HP,Q))</span>
<span class="s2">end</span>

<span class="s0">testetout()</span></pre>
</body>
</html>